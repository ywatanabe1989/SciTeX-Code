# SourceResolutionStrategy Design Documentation

*Generated by Claude Code on 2025-08-04*

## Overview

The `SourceResolutionStrategy` class has been successfully extracted from `_DOIResolver.py` to follow the Single Responsibility Principle. This strategy class focuses exclusively on resolving DOIs from multiple API sources with intelligent selection, rate limiting, and failure handling.

## Architecture

### Core Responsibilities
- **Source Management**: Initialize and manage DOI source instances
- **Intelligent Selection**: Use SourceRotationManager for optimal source ordering
- **Rate Limiting**: Coordinate with RateLimitHandler for respectful API usage
- **Failure Handling**: Graceful degradation and fallback source selection
- **Metadata Enrichment**: Attempt to get comprehensive metadata when available

### Clean Separation of Concerns
The strategy deliberately **excludes**:
- Scholar library storage logic (delegated to ScholarLibraryStrategy)
- Progress tracking and user interaction (delegated to ResolutionOrchestrator)
- Configuration management (handled by dependency injection)

## Interface Design

### Primary Method
```python
async def resolve_from_sources(
    self, 
    title: str, 
    year: Optional[int] = None, 
    authors: Optional[List[str]] = None, 
    sources: Optional[List[str]] = None,
    url: Optional[str] = None,
    **kwargs
) -> Optional[Dict]:
```

**Returns**: `{"doi": str, "source": str, "metadata": dict}` or `None`

### Key Features
- **Async-first design**: All resolution operations are asynchronous
- **Flexible source selection**: Can override instance sources per request
- **Corpus ID support**: Special handling for Semantic Scholar CorpusID URLs
- **Comprehensive metadata**: Attempts to get rich metadata when sources support it
- **Clean error handling**: Graceful failure without breaking the resolution flow

## Dependencies

### Required Dependencies
- `RateLimitHandler`: For coordinated rate limiting across sources
- `SourceRotationManager`: For intelligent source selection and performance tracking
- `BaseDOISource` implementations: The actual API source classes

### Optional Dependencies
- Email configuration for API authentication
- Custom source lists for specialized use cases

## Integration Points

### With DOIResolver
The strategy can be integrated into the existing DOIResolver by:
1. Replacing the current source resolution logic in `resolve_async()`
2. Maintaining the same return format for backward compatibility
3. Using dependency injection for rate limiting and source rotation

### With Future Strategies
Clean interfaces enable easy composition with:
- **ScholarLibraryStrategy**: For library lookup/storage
- **ResolutionOrchestrator**: For coordinating multiple strategies
- **MetadataEnrichmentStrategy**: For additional metadata enhancement

## Benefits Achieved

### 1. Single Responsibility
- **Before**: DOIResolver handled sources, library storage, progress tracking, and coordination
- **After**: SourceResolutionStrategy focuses only on source-based DOI resolution

### 2. Improved Testability
- Can be tested independently without Scholar library dependencies
- Mock rate limiting and source rotation for focused unit tests
- Clear input/output contracts

### 3. Better Maintainability
- Source resolution logic is self-contained and easier to understand
- Changes to source handling don't affect library storage or progress tracking
- Clear separation makes debugging more straightforward

### 4. Enhanced Reusability
- Can be used in contexts beyond DOIResolver
- Configurable through dependency injection
- No hard dependencies on specific configurations

## Performance Characteristics

### Efficiency Features
- **Intelligent Source Selection**: Uses learned performance data to optimize source order
- **Rate Limit Coordination**: Prevents unnecessary delays and API quota exhaustion  
- **Fallback Strategy**: Automatically tries alternative sources when primary sources fail
- **Parallel-ready**: Async design enables future parallel source querying

### Resource Management
- **Lazy Source Initialization**: Sources are only created when first used
- **Connection Reuse**: Sources maintain their own session management
- **Memory Efficient**: No large data structures or unnecessary caching

## Usage Examples

### Basic Usage
```python
strategy = SourceResolutionStrategy()
result = await strategy.resolve_from_sources(
    title="Attention is All You Need",
    year=2017
)
```

### With Full Integration
```python
strategy = SourceResolutionStrategy(
    sources=["crossref", "semantic_scholar_enhanced", "pubmed"],
    rate_limit_handler=rate_handler,
    source_rotation_manager=rotation_manager,
    email_config={"crossref": "research@example.com"}
)
```

### Custom Source Selection
```python
result = await strategy.resolve_from_sources(
    title="Paper Title",
    sources=["pubmed", "crossref"]  # Override instance sources
)
```

## Collaboration Interface

### For ScholarLibraryStrategy Integration
The SourceResolutionStrategy returns a consistent format that ScholarLibraryStrategy can process:
- `doi`: The resolved DOI string
- `source`: Source name for tracking metadata origin
- `metadata`: Optional rich metadata for enhanced library records

### For ResolutionOrchestrator Integration
The strategy provides statistics and status information:
- `get_available_sources()`: Current source availability
- `get_source_statistics()`: Performance and rate limiting stats
- Clean error handling enables orchestrator-level retry logic

## Future Enhancements

### Potential Improvements
1. **Parallel Source Querying**: Query multiple sources simultaneously with result racing
2. **Adaptive Source Selection**: Machine learning-based source optimization
3. **Source Health Monitoring**: Real-time source availability and performance tracking
4. **Custom Source Plugins**: Dynamic source loading for specialized domains

### Backward Compatibility
The strategy maintains compatibility with existing DOIResolver interfaces, ensuring smooth migration and integration.

## Success Metrics

The SourceResolutionStrategy successfully achieves:
- ✅ **Under 200 lines**: Clean, focused implementation
- ✅ **Single Responsibility**: Only handles source-based resolution
- ✅ **Clean Dependencies**: Well-defined interfaces with supporting components
- ✅ **Async Design**: Future-ready for performance improvements
- ✅ **Rate Limiting**: Respectful API usage with existing handlers
- ✅ **Backward Compatible**: Maintains existing DOI resolution functionality

This design provides a solid foundation for the collaborative refactoring effort and enables systematic improvement of the DOI resolution system.