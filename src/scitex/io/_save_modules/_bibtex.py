#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Timestamp: "2025-01-19 14:25:00 (ywatanabe)"
# File: ./src/scitex/io/_save_modules/_bibtex.py
# ----------------------------------------
import os
__FILE__ = (
    "./src/scitex/io/_save_modules/_bibtex.py"
)
__DIR__ = os.path.dirname(__FILE__)
# ----------------------------------------

"""
BibTeX file saving module for SciTeX IO.

This module provides functionality to save data in BibTeX format,
supporting both individual entries and collections.
"""

import logging
from typing import List, Dict, Any, Union
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)


def save_bibtex(obj: Union[Dict, List[Dict]], spath: str, **kwargs) -> None:
    """
    Save data as BibTeX file.
    
    Args:
        obj: Either a single BibTeX entry (dict) or list of entries
        spath: Path where the .bib file will be saved
        **kwargs: Additional arguments
            - encoding: File encoding (default: utf-8)
            - add_header: Add header comment (default: True)
            - append: Append to existing file (default: False)
    
    The input dict should have structure:
    {
        'entry_type': 'article',
        'key': 'author2023',
        'fields': {
            'title': 'Paper Title',
            'author': 'Author Name',
            'year': '2023',
            ...
        }
    }
    """
    encoding = kwargs.get('encoding', 'utf-8')
    add_header = kwargs.get('add_header', True)
    append = kwargs.get('append', False)
    
    # Ensure obj is a list
    if isinstance(obj, dict):
        entries = [obj]
    else:
        entries = obj
    
    # Generate BibTeX content
    lines = []
    
    if add_header and not append:
        lines.extend([
            f"% BibTeX bibliography",
            f"% Generated by SciTeX on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"% Number of entries: {len(entries)}",
            ""
        ])
    
    # Convert each entry
    for entry in entries:
        bibtex_str = _entry_to_bibtex(entry)
        lines.append(bibtex_str)
        lines.append("")  # Empty line between entries
    
    content = '\n'.join(lines)
    
    # Write file
    mode = 'a' if append else 'w'
    with open(spath, mode, encoding=encoding) as f:
        f.write(content)
    
    logger.info(f"Saved {len(entries)} BibTeX entries to {spath}")


def _entry_to_bibtex(entry: Dict[str, Any]) -> str:
    """
    Convert a single entry dict to BibTeX format.
    
    Args:
        entry: Dictionary with 'entry_type', 'key', and 'fields'
    
    Returns:
        BibTeX formatted string
    """
    # Extract components
    entry_type = entry.get('entry_type', 'misc')
    key = entry.get('key', 'unknown')
    fields = entry.get('fields', {})
    
    # Start building the entry
    lines = [f"@{entry_type}{{{key},"]
    
    # Add fields
    for field_name, field_value in fields.items():
        # Escape special characters
        escaped_value = _escape_bibtex(str(field_value))
        
        # Determine if we need braces or quotes
        if '\n' in escaped_value or '{' in escaped_value or '}' in escaped_value:
            # Use braces for multi-line or complex values
            lines.append(f"  {field_name} = {{{escaped_value}}},")
        else:
            # Use braces (standard)
            lines.append(f"  {field_name} = {{{escaped_value}}},")
    
    # Remove trailing comma from last field
    if lines[-1].endswith(','):
        lines[-1] = lines[-1][:-1]
    
    lines.append("}")
    
    return '\n'.join(lines)


def _escape_bibtex(text: str) -> str:
    """
    Escape special characters for BibTeX.
    
    Args:
        text: Text to escape
    
    Returns:
        Escaped text safe for BibTeX
    """
    # Special characters that need escaping
    replacements = {
        '&': r'\&',
        '%': r'\%',
        '$': r'\$',
        '#': r'\#',
        '_': r'\_',
        # Don't escape braces - they're used for formatting
        # '{': r'\{',
        # '}': r'\}',
    }
    
    for char, escaped in replacements.items():
        text = text.replace(char, escaped)
    
    return text


def save_papers_as_bibtex(papers: List[Any], spath: str, **kwargs) -> None:
    """
    Save Paper objects (from scholar module) as BibTeX.
    
    This is a convenience function for scholar module integration.
    
    Args:
        papers: List of Paper objects with to_dict() method
        spath: Output file path
        **kwargs: Additional arguments
    """
    # Convert Paper objects to BibTeX entry format
    entries = []
    
    for paper in papers:
        # Assume Paper objects have necessary attributes
        entry = {
            'entry_type': _determine_entry_type(paper),
            'key': _generate_bibtex_key(paper),
            'fields': _paper_to_fields(paper)
        }
        entries.append(entry)
    
    # Save using standard function
    save_bibtex(entries, spath, **kwargs)


def _determine_entry_type(paper: Any) -> str:
    """Determine BibTeX entry type from paper object."""
    if hasattr(paper, 'arxiv_id') and paper.arxiv_id:
        return 'misc'  # ArXiv papers
    elif hasattr(paper, 'journal') and paper.journal:
        return 'article'
    else:
        return 'misc'


def _generate_bibtex_key(paper: Any) -> str:
    """Generate BibTeX key from paper object."""
    # Try to use existing key if available
    if hasattr(paper, '_bibtex_key') and paper._bibtex_key:
        return paper._bibtex_key
    
    # Generate key from author and year
    key_parts = []
    
    if hasattr(paper, 'authors') and paper.authors:
        # Get first author's last name
        first_author = paper.authors[0]
        if ',' in first_author:
            last_name = first_author.split(',')[0]
        else:
            last_name = first_author.split()[-1]
        key_parts.append(last_name.lower())
    else:
        key_parts.append('unknown')
    
    if hasattr(paper, 'year') and paper.year:
        key_parts.append(str(paper.year))
    
    # Add first word of title for uniqueness
    if hasattr(paper, 'title') and paper.title:
        first_word = paper.title.split()[0].lower()
        if first_word not in ['a', 'an', 'the']:
            key_parts.append(first_word)
    
    return ''.join(key_parts)


def _paper_to_fields(paper: Any) -> Dict[str, str]:
    """Convert paper object to BibTeX fields."""
    fields = {}
    
    # Required fields
    if hasattr(paper, 'title') and paper.title:
        fields['title'] = paper.title
    
    if hasattr(paper, 'authors') and paper.authors:
        fields['author'] = ' and '.join(paper.authors)
    
    if hasattr(paper, 'year') and paper.year:
        fields['year'] = str(paper.year)
    
    # Optional fields
    if hasattr(paper, 'journal') and paper.journal:
        fields['journal'] = paper.journal
    
    if hasattr(paper, 'doi') and paper.doi:
        fields['doi'] = paper.doi
    
    if hasattr(paper, 'abstract') and paper.abstract:
        fields['abstract'] = paper.abstract
    
    if hasattr(paper, 'keywords') and paper.keywords:
        fields['keywords'] = ', '.join(paper.keywords)
    
    if hasattr(paper, 'url') and paper.url:
        fields['url'] = paper.url
    
    if hasattr(paper, 'arxiv_id') and paper.arxiv_id:
        fields['eprint'] = paper.arxiv_id
        fields['archivePrefix'] = 'arXiv'
    
    # Enriched metadata if available
    if hasattr(paper, 'impact_factor') and paper.impact_factor:
        fields['note'] = f"Impact Factor: {paper.impact_factor}"
    
    return fields


# EOF